{"meta":{"title":"Charblus-blog","subtitle":null,"description":null,"author":"CharBlus","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-12-24T18:11:05.000Z","updated":"2019-03-26T11:33:28.881Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ngular6开发不完全笔记（三）-- 报错指南","slug":"angular-errer","date":"2019-01-22T14:01:25.000Z","updated":"2019-03-26T11:33:28.877Z","comments":false,"path":"2019/01/22/angular-errer/","link":"","permalink":"http://yoursite.com/2019/01/22/angular-errer/","excerpt":"","text":"router Uncaught Error: Template parse errors:‘router-outlet’ is not a known element: If ‘router-outlet’ is an Angular component, then verify that it is part of this module. If ‘router-outlet’ is a Web Component then add ‘CUSTOM_ELEMENTS_SCHEMA’ to the &#39;@NgModule.schemas‘ of this component to suppress this message. 解决方法 每个模块中都添加 import { RouterModule } from &#39;@angular/router&#39;; 然后 import即可 【推荐】建立shared模块 在分享模块中导入 RouterModule 然后导出，其他有使用 &lt;router-outlet&gt;&lt;/router-outlet&gt; 的模块都导入 shared模块 主要是导入RouterModule指令， 根据自己的写法调整， 二者选一即可","categories":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/categories/angular/"},{"name":"分类2","slug":"angular/分类2","permalink":"http://yoursite.com/categories/angular/分类2/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"}],"keywords":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/categories/angular/"},{"name":"分类2","slug":"angular/分类2","permalink":"http://yoursite.com/categories/angular/分类2/"}]},{"title":"js-design-model","slug":"js-design-model","date":"2019-01-12T17:34:28.000Z","updated":"2019-03-26T11:33:28.879Z","comments":false,"path":"2019/01/13/js-design-model/","link":"","permalink":"http://yoursite.com/2019/01/13/js-design-model/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"分类2","slug":"前端/分类2","permalink":"http://yoursite.com/categories/前端/分类2/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"分类2","slug":"前端/分类2","permalink":"http://yoursite.com/categories/前端/分类2/"}]},{"title":"scss","slug":"scss","date":"2019-01-09T19:59:01.000Z","updated":"2019-03-26T11:33:28.880Z","comments":false,"path":"2019/01/10/scss/","link":"","permalink":"http://yoursite.com/2019/01/10/scss/","excerpt":"","text":"sass嵌套 选择器嵌套 这里的 &amp; 代表 nav a ,理解起来有点 像js中this 的意思 123456&lt;header&gt; &lt;nav&gt; &lt;a href=\"#\"&gt;home&lt;/a&gt; &lt;a href=\"#\"&gt;page&lt;/a&gt; &lt;/nav&gt;&lt;/header&gt; 1234567nav a &#123; color:red;&#125;header nav a &#123; color:green;&#125; 123456789nav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125; &#125; 属性嵌套(有相同的属性前缀) 如 font, background等，也有可能是 -webkit- 1234.box &#123; font-size: 12px; font-weight: bold;&#125; 123456.box &#123; font: &#123; size: 12px; weight: bold; &#125; &#125; 伪类嵌套 同上选择器嵌套一样 使用 &amp; 关键字 1234567891011.clearfix&#123;&amp;:before,&amp;:after &#123; content:\"\"; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125; 12345678clearfix:before, .clearfix:after &#123; content: \"\"; display: table;&#125;.clearfix:after &#123; clear: both; overflow: hidden;&#125; 占位符：语法：%placeholder，\b用法：占位符不被 @extend 调用不产生任何代码 1234567891011%bg &#123; background-color: #FF0;&#125;%w &#123; width: 100px;&#125;.box &#123; @extend %w; height: 100px; @extend %bg;&#125; sass 语法允许使用变量 以 $ 开头 1234$test: #ff9500div&#123; color: $test;&#125; 也可以字符串拼接 12345$side : left; .rounded &#123; border-#&#123;$side&#125;-radius: 5px; &#125; 也可以加减乘除 简单计算 sass分享：内容：全局、默认、局部变量使用：默认变量 在局部中无效，覆盖 默认变量 不分上下顺序 123&lt;div class=\"box1\"&gt; &lt;div class=\"box2\"&gt;box2&lt;/div&gt;&lt;/div&gt; 12345678910111213$backgroundColor: #FF0; // 全局变量$backgroundColor: #000 !default; // 默认变量$color: #F0F;.box1 &#123; $color: #CCC; // 局部变量 width: 100px; height: 100px; background-color: $backgroundColor; // #FF0 .box2 &#123; color: $color; // #CCC &#125;&#125; 控制指令 (Control Directives)混合指令 mixin 技术文档翻译 混合类型mixing 混合 （mix 的现在分词） mixin sass官方文档称 混合指令@mixin 为定义混合指令@include 为引用楼上定义的混合指令 123456789&lt;div class= \"parent\"&gt;111&lt;/div&gt;&lt;div class= \"child\"&gt;222&lt;/div&gt;&lt;div class= \"test\"&gt;333&lt;/div&gt; 1234567891011121314.parent &#123; color: red;&#125;.child &#123; @extend .parent; font-size: (21px * 3);&#125;@minxin auto &#123; margin: 0 auto;&#125;.test &#123; width: 200px; @include auto;&#125; sass 的 @if 控制指令1&lt;div class=\"demo\"&gt;&lt;/div&gt; 单独使用@if： 当@if 的表达式不是false或者null时， 条件成立， 输出{} 内的代码 123456789101112131415161718192021222324.demo&#123; $fx: bottom; @if ($fx == top) &#123; border-color: transparent transparent pink transparent; border-style: dashed dashed solid dashed; &#125; @else if($fx == right)&#123; border-color: transparent transparent transparent pink; border-style: dashed dashed dashed solid; &#125; @else if($fx == bottom)&#123; border-color: pink transparent transparent transparent; border-style: solid dashed dashed dashed; &#125; @else if($fx == left)&#123; border-color: transparent pink transparent transparent; border-style: dashed solid dashed dashed; &#125; width: 0px; height: 0px; overflow: hidden; border-width: 60px;&#125; 混合指令 + @if 指令 12345678910111213141516171819202122232425262728293031// 画三角形@mixin声明@mixin sj($fx:top,$size:100px,$color:red)&#123; @if ($fx == top) &#123; border-color: transparent transparent $color transparent; border-style: dashed dashed solid dashed; &#125; @else if($fx == right)&#123; border-color: transparent transparent transparent $color; border-style: dashed dashed dashed solid; &#125; @else if($fx == bottom)&#123; border-color: $color transparent transparent transparent; border-style: solid dashed dashed dashed; &#125; @else if($fx == left)&#123; border-color: transparent $color transparent transparent; border-style: dashed solid dashed dashed; &#125; width: 0px; height: 0px; overflow: hidden; border-width: $size;&#125;//mixin的调用.demo&#123; @include sj(left, 66px, pink);&#125; less 与sass有个很明显的区别变量 咱们sass 变量用 $ 开头less 是以 @ 开头的 sass语法 @for 控制指令 @for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动； 这个指令包含两种格式：@for $var from through ， 或者 @for $var from to 123456789&lt;ul&gt; &lt;li class=\"item-1\"&gt;至尊魔法师&lt;/li&gt; &lt;li class=\"item-2\"&gt;王&lt;/li&gt; &lt;li class=\"item-3\"&gt;奇异博士&lt;/li&gt; &lt;li class=\"item-4\"&gt;莫度男爵&lt;/li&gt; &lt;li class=\"item-5\"&gt;哈姆雷特&lt;/li&gt; &lt;li class=\"item-6\"&gt;蜘蛛侠&lt;/li&gt; &lt;li class=\"item-7\"&gt;非人哉&lt;/li&gt;&lt;/ul&gt; from … through // 当使用 through 时，条件范围包含 与 的值 // 个人分析： 可以将一个页面，不同div中嵌套的元素设置样式，只要命名符合一定的规律 1234567@for $i from 1 through 7 &#123; .item-#&#123;$i&#125; &#123; width: 6em * $i; background: pink; margin: 6px 0; &#125;&#125; from … to 使用 to 时条件范围只包含 的值不包含 的值。另外，$var 可以是任何变量，比如 $i； 和 必须是整数值。1234567@for $i from 1 to 7 &#123; .item-#&#123;$i&#125; &#123; width: 6em * $i; background: pink; margin: 6px 0; &#125;&#125; 12345@each $usr in nezha, aolie, xiaoyu, xiaotian &#123; .#&#123;$usr&#125;-avatar &#123; background-image: url(&apos;/img/#&#123;$usr&#125;.png&apos;); &#125;&#125; @each 后面的 $usr 变量用于保存每次遍历到的元素，然后使用差值语法（#{var}）来拼接正确的图片路径 //@each 指令同样可以用于循环输出，和 @for 的差别在于，@each 通过遍历 list 或者 map 实现循环输出// 如果遍历的对象是一个 map，那么我们就可以使用两个变量来存储元素的 key 和 value 1234567$frz: ( usr1:xiaotian, usr2:sanyan, usr3:shancai, usr4:longnv );@each $key, $usr in $frz &#123; .#&#123;$usr&#125;-avatar &#123; background-image: url(&apos;/img/#&#123;$usr&#125;.png&apos;); &#125;&#125; 运算的坑 加号居然可以不需要空格隔开,但必须单位统一 1234567891011$sidebar-width: 220px;$content-width: 720px;$gap-width: 20px;$other-width: 2em;.container &#123; // width: $sidebar-width+$content-width + $gap-width; width: $sidebar-width + $other-width; margin: 0 auto;&#125; 还可以做字符连接 如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 1234p:before &#123; content: \"bing\" + jian; font-family: sans- + \"serif\";&#125; 编译后 1234p:before &#123; content: \"bingjian\"; font-family: sans-serif;&#125; 减法 - 需要注意空格了，否则就完蛋喽 123456$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125; 乘法能够支持多种单位（比如 em ,px , %）；如果进行乘法运算时，两个值单位相同时，只需要为一个数值提供单位即可(多个乘数中只需要一个乘数提供单位，否则报错)。 123.box &#123; width: 10px * 2;&#125; 否则 123.box &#123; width: 10px * 6px;&#125; error: 60px*px isn’t a valid CSS value. 除法 众所周知“/”符号在 CSS 中已做为一种符号使用。其在 CSS 中通常起到分隔数字的用途，因此在 Sass 中做除法运算时，直接使用“/”符号做为除号时，将不会生效，编译时既得不到我们需要的效果，也不会报错。需要给运算的外面添加一个小括号()才能执行除法运算 123.box &#123; width: (100px / 2);&#125; 总结: ”/ ”符号被当作除法运算符时有以下几种情况： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。 如果数值被圆括号包围。 如果数值是另一个数学表达式的一部分。 12345678p &#123; font: 10px/8px; // 纯 CSS，不是除法运算 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 width: round(1.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125; 还有一种情况 Sass 的除法运算还有一个情况。先回忆一下，在乘法运算时，如果两个值带有相同单位时，做乘法运算时，出来的结果并不是我们需要的结果。但在除法运算时，如果两个值带有相同的单位值时，除法运算之后会得到一个不带单位的数值。 123.box &#123; width: (1000px / 100px);ß&#125; 颜色运算 - 分段运算 所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如： 1234p &#123; background-color: #012423 + #120923; color: #324334 * 2&#125; 有顺工作将所有的Mixins、Placeholder、Functions和变量放置在一起。将他们放置一起，可以确认他们可以很快的编写以及将来重复使用。 整站的元素应该放在一个base文件夹中。base文件夹应该包括全局的变量，如字体和颜色等 对于特定模块的Mixins、Functions 和变量，为了保证模块能正常运行，需要将这些集中放置在module文件中 限制嵌套使用嵌套的黄金规则： 嵌套永远不要超过三个层级 确保输出的CSS简洁、可重用 使用嵌套是很有意义的，而不是默认选项 过度的嵌套会导致很多问题的发生,代码变得复杂，而且太过于依赖HTML结构。这样将导致后面的样式需要使用!important来覆盖 scss 基本用法 变量（局部/全局）声明：$+变量名：变量值；默认变量在变量名后加default，!global变成全局变量。 混合宏（可重用的代码块）：声明混合宏@mixin border-radius { }； 调用混合宏 @include。 border-radius; 声明的时候还可以带默认参数，调用可以传参。 继承： @extend .btn; 继承btn class。任何选择器都能继承，可以连续继承。 占位符%：占位符声明的代码如果不被@extend调用，就不会被编译产生css代码。 插值：#{$参数名}，插入传入或定义的参数。 注释：/ / :会在编译出来的css文件中显示；//内容：不会显示。/!/：重要注释，任何style的css文件中都会有，一般放置css文件版权说明等信息。 加减法：同单位的数值之间可以做加减法。 乘除法：只能乘数值；如果除式中没有变量或者不是在一个数学表达式中（有加法减法等），就要将除式运算用小括号括起来，否则“/”不会被当做除号运算。 颜色运算：算术运算都支持颜色值，并且是分段计算的，01+05=06 字符串连接：+，$content: “Hello” + “” + “Sass!”;cursor: e + -resize；有引号的字符串和没有引号的字符串相加，以左边字符有无引号为准。 父类选择器：&amp;，表示引用父元素， if语法：@if,@else, 循环语法：@for,@while,@each, 函数：@function double ($number){ @return $number*2; } import：导入其他的scss","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"分类2","slug":"前端/分类2","permalink":"http://yoursite.com/categories/前端/分类2/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"分类2","slug":"前端/分类2","permalink":"http://yoursite.com/categories/前端/分类2/"}]},{"title":"ngular6开发不完全笔记（一）-- 管道","slug":"angular-pipe","date":"2019-01-09T19:43:12.000Z","updated":"2019-03-26T11:33:28.877Z","comments":false,"path":"2019/01/10/angular-pipe/","link":"","permalink":"http://yoursite.com/2019/01/10/angular-pipe/","excerpt":"","text":"自定义管道 管道（过滤器）为过滤数据显示下列list数据 pip.ts 文件123456789101112import &#123; Pipe, PipeTransform &#125; from '@angular/core';import &#123; TableType &#125; from './add-student.service';@Pipe(&#123; name: 'studyProjectType'&#125;)export class StudyProjectTypePipe implements PipeTransform &#123; transform( allstudyProjects: any[], typeParams: any): any &#123; // console.log(typeParams); return allstudyProjects.filter(type =&gt; typeParams.indexOf(type.type) !== -1); &#125;&#125; transform 方法是管道的基本要素。 PipeTransform接口中定义了它. 当每个输入值被传给 transform 方法时，还会带上另一个参数allstudyProjects 是输入值 ，也就是html 页面中 | 前面的studyProjectList是管道名 typeParams是管道名后的参数 传进管道中以上这两个为形参，名字自定义，建议命名规范，尤其是写分享管道 . transform 函数里return 是输入数据过滤filter，里面是一个函数 这里的思路是 对比 请求下的数据 studyProjectList 每个列表的type属性 对比下面typeParams, 结果为true 就通过过滤显示 本地数据来源1234567891011121314151617181920212223public types: TabType[] = [ &#123; name: &apos;课程&apos;, id: &apos;courseDate&apos;, tags: [&apos;在线课&apos;, &apos;线上课&apos;, &apos;直播课&apos;, &apos;线下课&apos;], &#125;, &#123; name: &apos;考试&apos;, id: &apos;examDate&apos;, tags: [&apos;试卷&apos;], &#125;, &#123; name: &apos;作业&apos;, id: &apos;taskDate&apos;, tags: [&apos;作业&apos;], &#125;, &#123; name: &apos;问卷&apos;, id: &apos;questionnaireDate&apos;, tags: [&apos;问卷&apos;], &#125;, ]; private typeParams: string[] = this.types[0].tags; //初始值 html 文件1234&lt;div class=&quot;table-responsive&quot;&gt; &lt;!-- &#123;&#123; studyProjectList | studyProjectType &#125;&#125; --&gt; &lt;app-project-assign-list [studyProjectList] = &quot;studyProjectList | studyProjectType: typeParams &quot;&gt;&lt;/app-project-assign-list&gt;&lt;/div&gt; app-project-assign-list 为列表样式组件1234//click 点击事件 改变types[i]switchType (i) &#123; this.typeParams = this.types[i].tags;&#125; 线上数据来源123456789101112131415161718192021/** 数据来源 * addStudentService 服务提供 getStudyProject方法 */dataSource: Observable&lt;any&gt;; // studyProjectList: Array&lt;any&gt; = []; studyProjectList: TableType[] = []; constructor( private addStudentService: AddStudentService, ) &#123; &#125; ngOnInit() &#123; this.dataSource = this.addStudentService.getStudyProject(); this.dataSource.subscribe( (data) =&gt; &#123; console.log(data); this.studyProjectList = data.students; &#125; ); &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"angular","slug":"前端/angular","permalink":"http://yoursite.com/categories/前端/angular/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"angular","slug":"前端/angular","permalink":"http://yoursite.com/categories/前端/angular/"}]},{"title":"font-end-dev-system-config","slug":"font-end-dev-system-config","date":"2019-01-06T19:53:44.000Z","updated":"2019-03-26T11:33:28.878Z","comments":false,"path":"2019/01/07/font-end-dev-system-config/","link":"","permalink":"http://yoursite.com/2019/01/07/font-end-dev-system-config/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"},{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"vue-notice","slug":"vue-notice","date":"2019-01-06T19:53:03.000Z","updated":"2019-03-26T11:33:28.880Z","comments":false,"path":"2019/01/07/vue-notice/","link":"","permalink":"http://yoursite.com/2019/01/07/vue-notice/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"},{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"angular6开发不完全笔记（一）","slug":"angular-notice","date":"2019-01-06T19:52:36.000Z","updated":"2019-03-26T11:33:28.877Z","comments":false,"path":"2019/01/07/angular-notice/","link":"","permalink":"http://yoursite.com/2019/01/07/angular-notice/","excerpt":"","text":"新建项目请在终端/控制台窗口中运行 ng -v 命令。 确定您已安装@angular/cliif没有执行 npm install -g @angular/cli 全局安装 Angular CLI。 1ng new project-name 就具体项目开发前调研技术栈追加相关参数 样式style 如 --style=scss value值可以是（css | scss | sass | less | stylus ）等 项目中使用路由routing 如 --routing 生成routing module 前缀 prefix 如 --prefix 或 -p 默认为app,参数自定义 比如 --prefix=wn 后话 angular.json 文件中 &quot;prefix&quot;: &quot;app&quot;, 会更改为&quot;prefix&quot;: &quot;wn&quot; tslint验证规则 项目中所有的组件前缀都改为wn开头的 index.html文件&lt;app-root&gt;&lt;/app-root&gt;变为&lt;wn-root&gt;&lt;wn-root&gt;所有 ng g c component-name 生成的组件 prefix默认时使用&lt;app-componet-name&gt;&lt;/app-componet-name&gt; 自定义前缀后 &lt;wn-componet-name&gt;&lt;/wn-componet-name&gt; #####综合上述 ng new project-name --style=scss --routing --prefix=wn 更多参数参考 ng new 启动项目ng serve 或者 npm run start 开发环境项目如开始对接接口需要配置本地代理 一般在根目录下添加proxy.config.json文件 1234567891011&#123; &quot;/api&quot;: &#123; &quot;target&quot;: &quot;http://xxx.xxx.com&quot;, &quot;secure&quot;: false, // &quot;logLevel&quot;:&quot;debug&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;:&#123; &quot;^/api&quot;:&quot;&quot; &#125; &#125;&#125; 文件package.json中scripts 下 start的value值ng serve --proxy-config proxy.config.json 或者在angular.json 中 serve下 options添加属性 &quot;proxyConfig&quot;：&quot;proxy.config.json&quot; ng serve 其他参数 接口默认4200 --port 4201 启动时自动打开浏览器 --open 简写-o 用host指定运行主机 --host 0.0.0.0 或--public-host 192.168.1.111 指定浏览器客户端将使用的URL 正在生成的应用程序的基URL --base-href /admin/或者 --base-href http://www.example.com/ 相当于index.html添加html标签 属性href规定页面中所有相对链接的基准 URL。 如 &lt;base href=&quot;http://www.example.com/&quot;&gt; 注：参数值后面一定要多个 / 结尾，否则无效 #####综合上述1（未对接） ng serve --port 4201 --open #####综合上述2 ng serve --proxy-config proxy.config.json --host 0.0.0.0 --port 4201 --open 更多参数参考 ng serve 项目开发 生成组件 ng g c component-name 生成在src下全局组件 ng g c module-name/component-name 组件生成在某模块下src下，并声明注册该模块 ng g c path/component-name 组件生成在项目path路径下，默认注册父模块，由父模块决定是否是全局组件还是某模块组件； 禁止生成spec.ts文件 生成模块 ng g m module-name 同上其他参数 --routing 生成路由模块。 --module 允许指定声明模块####综上： ng g m module-name --routing --module module-name 生成服务 ng g s service-name 同上 生成管道(原1.x中过滤器) ng g p pipe-name 生成指令 ng g d directive-name指令分 属性型指令和结构型指令 生成class ng g cl class-name class-mame一般首字母大写，驼峰 生成接口interface ng g i interface-name 接口为ts特性 类型检查 声明参数类型 更多参数参考 ng generate 编译项目ng build 或 npm run build 参数 --base-href /myUrl/ 相当于在index.html中添加，默认 --prod 通过UglifyJS 删除更多未使用的代码，使项目编译后更小体积 --output-hashing all 编译后输出文件名以哈希模式，便于缓存 --stats-json 生成一个“stats.json”文件，可以使用诸如：webpack bundle analyzer’或https://webpack.github.io/analyse.等工具进行前端分析。 --aot 启用aot预编译 --build-optimizer 使用“aot”选项时启用@angular-devkit/build-optimizer 优化。 更多参数参考 ng build","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"angular7","slug":"前端/angular7","permalink":"http://yoursite.com/categories/前端/angular7/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"angular7","slug":"前端/angular7","permalink":"http://yoursite.com/categories/前端/angular7/"}]},{"title":"font-end-text","slug":"font-end-text","date":"2019-01-06T19:51:17.000Z","updated":"2019-03-26T11:33:28.878Z","comments":false,"path":"2019/01/07/font-end-text/","link":"","permalink":"http://yoursite.com/2019/01/07/font-end-text/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"},{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"Egret引擎开发基础（一）","slug":"egret-primary","date":"2019-01-06T17:25:06.000Z","updated":"2019-03-26T11:33:28.878Z","comments":false,"path":"2019/01/07/egret-primary/","link":"","permalink":"http://yoursite.com/2019/01/07/egret-primary/","excerpt":"","text":"显示图片1234var batman:egret.Bitmap = new egret.Bitmap( RES.getRes(&apos;hexo-huaheshang_png&apos;));batman.x = 0;batman.y = 20;this.addChild( batman ); 改变图片显示深度（层级）1234567891011121314151617var batman:egret.Bitmap = new egret.Bitmap( RES.getRes(&apos;hexo-huaheshang_png&apos;)); batman.x = 0; batman.y = 20; this.addChild( batman ); var batman1:egret.Bitmap = new egret.Bitmap( RES.getRes(&apos;hexo-huaheshang_png&apos;)); batman1.x = 60; batman1.y = 60; this.addChild( batman1 ); var batman2:egret.Bitmap = new egret.Bitmap( RES.getRes(&apos;hexo-huaheshang_png&apos;)); batman2.x = 120; batman2.y = 80; this.addChild( batman2 ); this.setChildIndex(batman1, this.getChildIndex( batman2 )); // 获取batman2 深度 给batmain1 Tween 动画1234567this.stage.addEventListener(egret.TouchEvent.TOUCH_TAP, () =&gt; &#123;egret.Tween.get(batman).to(&#123;x: batman1.x&#125;, 300, egret.Ease.circIn )egret.Tween.get(batman1).to(&#123;x: batman.x&#125;, 300, egret.Ease.circIn )egret.Tween.get( batman1 ).to( &#123;scaleX: .4, scaleY:.4, alpha: .3&#125;, 300, egret.Ease.circIn).to(&#123;scaleX: 1, scaleY: 1, alpha: 1&#125;, 300, egret.Ease.circIn)&#125;, this); 声音1var sound:egret.Sound = RES.getRes(&apos;jimp_mp3&apos;); sound.play(); 手册文档命令行手册 UI扩展库 旧版GUI 新版EUI","categories":[{"name":"Egret","slug":"Egret","permalink":"http://yoursite.com/categories/Egret/"},{"name":"分类2","slug":"Egret/分类2","permalink":"http://yoursite.com/categories/Egret/分类2/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"},{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"}],"keywords":[{"name":"Egret","slug":"Egret","permalink":"http://yoursite.com/categories/Egret/"},{"name":"分类2","slug":"Egret/分类2","permalink":"http://yoursite.com/categories/Egret/分类2/"}]},{"title":"前端开发功能--参考网站统计","slug":"font-end-good-website","date":"2019-01-03T16:45:21.000Z","updated":"2019-03-26T11:33:28.878Z","comments":false,"path":"2019/01/04/font-end-good-website/","link":"","permalink":"http://yoursite.com/2019/01/04/font-end-good-website/","excerpt":"","text":"codemirror.net CodeMirror是一个用JavaScript实现的多功能文本编辑器。它专门用于编辑代码，并带有许多语言模式和插件 ，可实现更高级的编辑功能。 Linux运维日志 .centos.bz","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"},{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"经查-- git使用报错及解决办法","slug":"git-error","date":"2018-12-31T08:14:34.000Z","updated":"2019-03-26T11:33:28.878Z","comments":false,"path":"2018/12/31/git-error/","link":"","permalink":"http://yoursite.com/2018/12/31/git-error/","excerpt":"","text":"git push 错误 failed to push some refs to 'git@github.com:charblus/ ...' ```123456&gt; 本地和远程的文件应该合并后才能上传本地的新文件解决办法1： 先拉(pull)后推(push) 解决办法2： 导致这种报错2是因为没有git add 就去提交空，一般因为这个出现这个问题，此报错上还有一行: `error: src refspec master does not match any.`### git pull 错误 ``` fatal: refusing to merge unrelated histories 更新代码失败git pull origin master --allow-unrelated-histories后面加上 –allow-unrelated-histories ， 把两段不相干的 分支进行强行合并 git add . &amp;&amp; git commit -m &quot;***&quot; &amp;&amp; git push origin mastercankao git branch 错误 fatal: Not a valid object name: &#39;master&#39;.git项目下没有任何文件可以commit，或没有新项目没有一次commit ,是不能创建分支的；只有先commit之后才会真正建立master分支，此时才可以建立其它分支。 由于刚创建的git仓库默认的master分支要在第一次有效的commit之后（可以先不push）才会真正建立，否则就像你声明了个对象但没初始化一样。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"工具","slug":"git/工具","permalink":"http://yoursite.com/categories/git/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"工具","slug":"git/工具","permalink":"http://yoursite.com/categories/git/工具/"}]},{"title":"windows 常用快捷键和dos命令","slug":"windows-cmd","date":"2018-12-30T21:27:26.000Z","updated":"2019-03-26T11:33:28.881Z","comments":false,"path":"2018/12/31/windows-cmd/","link":"","permalink":"http://yoursite.com/2018/12/31/windows-cmd/","excerpt":"","text":"快捷键win + R 打开dos命令行窗口win + E 打开资源管理窗口 （计算机） shift + 鼠标右击 + select 在此处打开命令窗口 可在资源管理目录下打开dos命令 windows下chrome 快捷键ctrl + E 地址栏foucs搜索(默认搜索引擎) 常用dos命令 win键 + R 点击确定，打开命令行窗口 或 运行的设置窗口，在输入栏里输入cmd，然后点击确定 注： mac 和linux 目录都是 c:/dev/nvm 而windows 是 c:\\dev\\nvm del 删除del /? // 查看删除帮助del c:\\settings.txt // 删除指定文件del /F /S /Q c:\\dev // 删除文件夹 12345/P 删除每一个文件之前提示确认。/F 强制删除只读文件。/S 删除所有子目录中的指定的文件。/Q 安静模式。删除全局通配符时，不要求确认/A 根据属性选择要删除的文件","categories":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/categories/windows/"},{"name":"工具","slug":"windows/工具","permalink":"http://yoursite.com/categories/windows/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"命令行","slug":"命令行","permalink":"http://yoursite.com/tags/命令行/"}],"keywords":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/categories/windows/"},{"name":"工具","slug":"windows/工具","permalink":"http://yoursite.com/categories/windows/工具/"}]},{"title":"Serverless services -- 无服务器服务","slug":"Serverless-services","date":"2018-12-26T18:15:54.000Z","updated":"2019-03-26T11:33:28.877Z","comments":false,"path":"2018/12/27/Serverless-services/","link":"","permalink":"http://yoursite.com/2018/12/27/Serverless-services/","excerpt":"","text":"Serverless被翻译为“无服务器架构”，这个概念在2012年时便已经存在，比微服务和Service Mesh的概念出现都要早，但是直到微服务概念大红大紫之后，Serverless才重新又被人们所关注。 Serverless（无服务器架构）并不意味着没有任何服务器去运行代码，Serverless是无需管理服务器，只需要关注代码，而提供者将处理其余部分工作。“无服务器架构”也可以指部分服务器端逻辑依然由应用程序开发者来编写的应用程序，但与传统架构的不同之处在于，这些逻辑运行在完全由第三方管理，由事件触发的无状态（Stateless）暂存于计算容器内。 对于开发者来说，Serverless架构可以将其服务器端应用程序分解成多个执行不同任务的函数，整个应用分为几个独立、松散耦合的组件，这些组件可以在任何规模上运行。 Serverless架构优势缩短交付时间： Serverless架构允许开发人员在极短时间内（几小时、几天）交付新的应用程序，而不是像以前一样需要几个星期或几个月。在新的应用程序中，依赖于第三方API提供服务的例子很多，如认证(OAuth)、社交、地图、人工智能等。 增强可伸缩性：所有人都希望自己开发的应用能够快速获取大量的新增用户，但是当活跃用户快速增长的时候，服务器的压力也会激增。使用Serverless架构的体系不再有上述担忧，可以及时、灵活进行扩展来应对快速增长的活跃用户带来的访问压力。 降低成本： Serverless架构模式可以降低计算能力和人力资源方面的成本，如果不需要服务器，就不用花费时间重新造轮子、风险监测、图像处理，以及基础设施管理，操作成本会直线下降。 改善用户体验： 用户通常不太关心基础设施，而更注重于功能和用户体验。Serverless架构允许团队将资源集中在用户体验上。 减少延迟及优化地理位置信息：应用规模能力取决于三个方面：用户数量、所在位置及网络延迟。当应用要面向全国甚至全球用户的时候，通常会产生较高的延迟，从而降低用户体验。在Serverless架构下，供应商在每个用户附近都有节点，大幅度降低了访问延迟，因此所有用户的体验都可以得到提升。 在微服务与容器技术火热之后，Serverless（无服务器架构）成为新的热点，无服务器云函数可以让用户无需关心服务器的部署运营，只需开发最核心的业务逻辑，即可实现上线运营，具备分布容灾能力，可以依据负载自动扩缩容，并按照实际调用次数与时长计费。 使用Serverless架构可以免除所有运维性操作，开发人员可以更加专注于核心业务的开发，实现快速上线和迭代，把握业务发展的节奏。Serverless架构可以认为是对微服务和容器化的一种补充，为用户提供了一种新的选择，来应对复杂多变的需求，尤其适合快速发展的初创型公司。 国外: firebase 国内: 阿里百川 友盟 文章Angular &amp;&amp; Serverless Google FireBase的简单介绍和使用","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"node包管理工具--nvm","slug":"node-nvm","date":"2018-12-26T18:04:27.000Z","updated":"2019-03-26T11:33:28.880Z","comments":false,"path":"2018/12/27/node-nvm/","link":"","permalink":"http://yoursite.com/2018/12/27/node-nvm/","excerpt":"","text":"mac 用nvm 管理node版本; (直接使用npm安装nrm, 不需要其他配置)windows 安装nvw-windows 使用nvm工具； windows使用nvm-noinstall.zip安装 nvm-noinstall.zip 这个是绿色免安装版本，但是使用之前需要配置 nvm-windows 下载下载最新版本 Assets下 nvm-noinstall.zip文件 把nvm_noinstall.zip解压到比如 C:/dev/nvm 中(其它盘也可以)； 右键以管理员的身份运行install.cmd . 直接按回车,在C盘根目录下会生成一个settins,txt.并拷贝到C:/dev/nvm.修改内容: 123456root: C:\\dev\\nvmpath: C:\\dev\\nodejsarch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ root 配置为当前nvm.exe所在的目录；path 配置为node快捷方式所在的目录；arch 配置为当前操作系统的位数（32/64）；proxy 表示代理，一般不用配置，有的直接设置为none；使用nvm install 8.11.1 下载node v8.11.1 版本，可能网速慢或者需要翻墙导致error下载失败，这里配置使用淘宝node镜像node_mirror和淘宝npm镜像npm_mirror 配置环境变量打开‘控制面板主页-&gt;高级系统设置-&gt;高级-&gt;环境变量’后会有‘用户变量’和‘系统变量’两个选项，建议在‘用户变量’里面设置: 123变量名: NVM_HOME 变量值: C:\\dev\\nvm变量名: NVM_SYMLINK 变量值: C:\\dev\\nodejs变量名: PATH: 变量值: %NVM_HOME%;%NVM_SYMLINK% (在PATH的最后添加%NVM_HOME%;%NVM_SYMLINK%) npm 相关配置 npm全局安装 npm config set prefix &quot;c:\\dev\\nvm\\npm&quot; 配置用npm下载包时全局安装的包路径 配置npm环境变量 变量名: NPM_HOME 变量值: c:\\dev\\nvm\\npm (一定要放在NVM_SYMLINK之前;第4步：在PATH的最后添加%NVM_HOME%;%NPM_HOME%;%NVM_SYMLINK%); nrm 安装和使用直接下载： npm install –g nrm镜像下载： npm install nrm –g --registry=https://registry.npm.taobao.org 12nrm ls // 列出所有镜像(下载源)nrm use taobao // 选择使用淘宝镜像 nvm 使用 nvm list 列出所有已经安装的nodejs版本 nvm install lastest 下载最新版本的nodejs nvm install 8.11.1 下载版本为v8.11.1的nodejs nvm use 8.11.1 使用指定版本 为v8.11.1的nodejs (注意：如果操作系统为32位的，使用nvm use [版本号] 命令时，后面要加上32。也就是nvm use 8.11.1 32 ） nvm ls available 查看可用的（可下载的）全部node版本 node -v 查看nodejs的版本号","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"工具","slug":"前端/工具","permalink":"http://yoursite.com/categories/前端/工具/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"},{"name":"工具","slug":"前端/工具","permalink":"http://yoursite.com/categories/前端/工具/"}]},{"title":"Hexo blog使用指南","slug":"hello-world","date":"2018-12-26T18:04:27.000Z","updated":"2019-03-26T11:33:28.879Z","comments":false,"path":"2018/12/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/12/27/hello-world/","excerpt":"","text":"What?Hexo 是一个快速、简洁且高效的博客框架。可以使用markdown 解析成文章，在几秒内，即可利用靓丽的主题生成静态网页。Why?笔记需要整理How?github 创建 charblus.github.io 项目使用markdown 记录开发笔记和文章日复一日 链接：Hexo官方网站Hexo官方主题 快速开始1234hexo n \"hexo-post\"hexo ghexo shexo d 创建一篇文章1$ hexo new \"My New Post\" More info: Writing 本地启动1$ hexo server More info: Server 生成静态html1$ hexo generate More info: Generating 部署远程服务1$ hexo deploy More info: Deployment hexo 命令简写1234hexo s == hexo server 用于生成静态文件hexo g == hexo generate 用于启动服务器，主要用来本地预览hexo d == hexo deploy 用于将本地文件发布到github等git仓库上hexo n == hexo new 用于新建一篇名为“my article”的文章 `hexo n “my article”` 创建菜单 sourse 添加文件夹 _name , 文件中添加index.md文件 修改主题的配置文件_config.yml,增加一个标签页菜单 参考文章 https://hexo.io/zh-cn/docs/index.html HEXO搭建个人博客 在Github上面搭建Hexo博客（一）：部署到Github Hexo在Github中搭建博客系统(4)建菜单写文章","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"git基本配置及使用","slug":"git","date":"2018-12-25T01:23:27.000Z","updated":"2019-03-26T11:33:28.879Z","comments":false,"path":"2018/12/25/git/","link":"","permalink":"http://yoursite.com/2018/12/25/git/","excerpt":"","text":"Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 git 命令[TOC] 设置git 基本配置 12$ git config --global user.name &quot;charblus&quot;$ git config --global user.email &quot;charblus7582@gmail.com&quot; 生成ssh 密钥 查看是否已经有了ssh密钥：cd ~/.ssh ; 如果没有密钥则不会有此文件夹，有则备份删除 生成密钥 （email@email.com是github的账号，即上面的email）1$ ssh-keygen -t rsa -C “email@email.com” 按3个回车，密码为空； 如果不执行第一步或没有删除：第一个回车后会出现coverage 提示你是否覆盖文件 yes/no；最后得到了两个文件：id_rsa和id_rsa.pub git remote1234git remote 不带参数，列出已经存在的远程分支git remote -v | --verbose 列出详细信息，在每一个名字后面列出其远程urlgit remote add origin ssh://***.git 添加远程仓库git remote show origin 显示远程信息 git-flow git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作git-flow 备忘清单 git merge 与 git rebase git merge 和 git rebase 都是将远程分支与本地分支合并的一种方法，git merge 会生成一个新的节点，例如A和B都位于同一个HEAD，A提交了2个commit C1和C2，B 提交了2个commit C3和C4，git merge的结果是在C3和C4之后合并生成C5，这样提交历史比较清晰，但多了一个C5 假设A已经将C1和C2 push到了远程分支，那么B 使用git rebase则会将C3和C4缓存到.git/rebase中，恢复到之前的状态，更新C1和C2，然后再将C3和C4作为补丁应用到C2的状态上。结果如下：原始状态 -&gt;C1-&gt;C2-&gt;C3&#39;-&gt;C4&#39;，C3’和C4’为git 根据C3和C4生成的补丁，log是一条直线，而且没有多余的C5，但是平行信息丢失。git pull和git pull –rebase之间的区别 参考廖雪峰git教程","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"前端","slug":"工具/前端","permalink":"http://yoursite.com/categories/工具/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"前端","slug":"工具/前端","permalink":"http://yoursite.com/categories/工具/前端/"}]}]}